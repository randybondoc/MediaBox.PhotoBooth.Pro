<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MediaBox.PhotoBooth.Pro — Demo</title>
  <style>
    :root{--accent:#1f6feb}
    html,body{height:100%;}
    body{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Arial; margin:0; background:#f4f6fb; color:#0b1220}
    header{padding:12px 16px;background:white;border-bottom:1px solid #e6e9ef;display:flex;gap:12px;align-items:center;justify-content:space-between}
    header h1{font-size:16px;margin:0}
    .wrap{display:flex;gap:16px;padding:16px;flex-wrap:wrap}
    .left,.right{background:white;padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(15,20,30,0.04)}
    .left{flex:1;min-width:320px}
    .right{width:420px;min-width:320px}
    video, canvas{max-width:100%;border-radius:8px;background:black}
    .controls{display:grid;gap:8px;margin-top:8px}
    label{font-size:13px;color:#394150}
    select,input[type="range"],input[type="number"],input[type="text"]{width:100%;padding:8px;border-radius:6px;border:1px solid #d7dde6}
    button{background:var(--accent);color:white;border:0;padding:10px 12px;border-radius:8px;cursor:pointer}
    .small{padding:6px 8px;font-size:13px}
    .flex{display:flex;gap:8px;align-items:center}
    .template-list{display:flex;gap:8px}
    .template{border:1px dashed #ccd4e0;padding:6px;border-radius:6px;cursor:pointer}
    .template.active{border-style:solid;background:linear-gradient(180deg,#f8fbff,#fff)}
    .overlay-preview, .result-preview{width:100%;height:220px;object-fit:contain;background:#eef2f7;border-radius:6px}
    .stage{position:relative;display:inline-block}
    .draggable{position:absolute;touch-action:none}
    .stage-canvas{background:#111;border-radius:6px}
    .footer{padding:12px;text-align:right}
    .note{font-size:13px;color:#5b6770}
    .thumb{width:80px;height:60px;object-fit:cover;border:1px solid #e3e8f0;border-radius:6px}
    .controls-grid{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .countdown-overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-size:72px;color:white;background:rgba(0,0,0,0.35);border-radius:8px}
    @media(max-width:880px){ .wrap{padding:8px} .right{width:100%} }
  </style>
</head>
<body>
  <header>
    <div style="display:flex;gap:12px;align-items:center">
      <h1>MediaBox.PhotoBooth.Pro — Demo</h1>
      <div class="note">Exports 4x6 (1200×1800 px). Works on desktop & mobile (HTTPS required).</div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <button id="startCameraBtn" class="small">Start Camera</button>
      <button id="restartBtn" class="small" style="background:#ef6f6f">Reset</button>
    </div>
  </header>

  <div class="wrap">
    <div class="left">
      <div style="position:relative">
        <video id="preview" autoplay playsinline muted class="stage-canvas" style="width:100%;height:310px;object-fit:cover;border-radius:8px"></video>
        <div id="countdown" class="countdown-overlay" style="display:none">3</div>
      </div>
      <canvas id="hiddenCanvas" width="640" height="480" style="display:none"></canvas>

      <div class="controls">
        <div class="flex"><label for="deviceSelect">Camera</label><select id="deviceSelect"></select></div>
        <div class="flex"><label for="facingMode">Facing</label>
          <select id="facingMode"><option value="user">Front</option><option value="environment" selected>Back</option></select>
        </div>
        <div class="flex"><label for="count">Photos</label><select id="count"><option>1</option><option>2</option><option>3</option><option selected>4</option></select></div>
        <div class="flex"><label for="layout">Layout</label>
          <div style="flex:1">
            <div class="template-list" id="templates">
              <div class="template active" data-template="grid2x2">2×2</div>
              <div class="template" data-template="strip3">3-strip</div>
              <div class="template" data-template="single">Single</div>
            </div>
          </div>
        </div>

        <div class="flex"><label for="delay">Countdown (s)</label><input id="delay" type="number" value="3" min="0" max="20"></div>

        <div class="flex">
          <button id="start" class="small">Start Capture</button>
          <button id="snap" class="small" style="background:#2ecc71">Snap Now</button>
        </div>

        <hr>

        <label>Overlay / Print Frame (PNG recommended)</label>
        <input id="overlayFile" type="file" accept="image/*">
        <img id="overlayPreview" class="overlay-preview" alt="overlay preview">

        <label>Background (for chroma)</label>
        <input id="bgFile" type="file" accept="image/*">
        <img id="bgPreview" class="overlay-preview" alt="background preview">

        <div class="flex"><input type="checkbox" id="chromaToggle"><label for="chromaToggle">Enable chroma key</label></div>
        <div class="flex"><label>Key color</label><input id="keyColor" type="color" value="#00ff00"></div>
        <div class="flex"><label>Threshold</label><input id="threshold" type="range" min="0" max="200" value="60"></div>

        <hr>

        <label>Add text</label>
        <div class="flex"><input id="textInput" placeholder="Caption..."><select id="fontSelect"><option>Arial</option><option>Georgia</option><option>Impact</option><option>Courier New</option><option selected>Roboto</option></select></div>
        <div class="flex"><button id="addText" class="small">Add Text</button><button id="clearTexts" class="small">Clear Texts</button></div>

        <hr>

        <div class="flex"><button id="export" class="small">Export 4×6 JPEG</button></div>

        <div style="margin-top:8px" class="note">Tip: On phones choose rear camera for higher quality. Use GitHub Pages (HTTPS) or localhost for camera access.</div>
      </div>
    </div>

    <div class="right">
      <div class="stage" id="stageHolder" style="width:360px;height:540px;border:1px solid #e3e8f0;overflow:hidden;background:#111;display:flex;align-items:center;justify-content:center">
        <canvas id="stageCanvas" width="360" height="540"></canvas>
      </div>

      <div style="margin-top:10px">
        <div class="note">Captured thumbnails</div>
        <div id="thumbs" style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap"></div>
      </div>

      <div style="margin-top:12px">
        <div class="note">Result preview (scaled)</div>
        <canvas id="resultPreview" class="result-preview" width="360" height="240"></canvas>
      </div>
    </div>
  </div>

  <div class="footer">
    <small class="note">Drag text overlays on the stage. Click export to download a print-ready 4×6 JPEG.</small>
  </div>

<script>
(async function(){
  // elements
  const preview = document.getElementById('preview');
  const deviceSelect = document.getElementById('deviceSelect');
  const startBtn = document.getElementById('start');
  const snapBtn = document.getElementById('snap');
  const hiddenCanvas = document.getElementById('hiddenCanvas');
  const hiddenCtx = hiddenCanvas.getContext('2d');
  const stageCanvas = document.getElementById('stageCanvas');
  const stageCtx = stageCanvas.getContext('2d');
  const resultPreview = document.getElementById('resultPreview');
  const resultCtx = resultPreview.getContext('2d');
  const overlayFile = document.getElementById('overlayFile');
  const overlayPreview = document.getElementById('overlayPreview');
  const bgFile = document.getElementById('bgFile');
  const bgPreview = document.getElementById('bgPreview');
  const chromaToggle = document.getElementById('chromaToggle');
  const keyColorEl = document.getElementById('keyColor');
  const thresholdEl = document.getElementById('threshold');
  const countEl = document.getElementById('count');
  const delayEl = document.getElementById('delay');
  const templates = document.getElementById('templates');
  const thumbs = document.getElementById('thumbs');
  const exportBtn = document.getElementById('export');
  const textInput = document.getElementById('textInput');
  const fontSelect = document.getElementById('fontSelect');
  const addTextBtn = document.getElementById('addText');
  const clearTextsBtn = document.getElementById('clearTexts');
  const resetBtn = document.getElementById('restartBtn');
  const startCameraBtn = document.getElementById('startCameraBtn');
  const countdownEl = document.getElementById('countdown');
  const facingSelect = document.getElementById('facingMode');

  // state
  let stream = null;
  let devices = [];
  let captures = [];
  let overlayImg = null;
  let bgImg = null;
  let template = 'grid2x2';
  let texts = []; // {text,x,y,font}

  // enumerate devices (video inputs)
  async function getDevices(){
    try{
      const list = await navigator.mediaDevices.enumerateDevices();
      devices = list.filter(d=>d.kind === 'videoinput');
      const cur = deviceSelect.value;
      deviceSelect.innerHTML = '';
      devices.forEach((d,i)=>{
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        opt.textContent = d.label || `Camera ${i+1}`;
        deviceSelect.appendChild(opt);
      });
      if(cur) deviceSelect.value = cur;
    }catch(e){ console.warn('enumerate devices failed', e); }
  }

  // start camera with either deviceId or facingMode
  async function startCamera({deviceId=null, facingMode=null} = {}){
    try{
      if(stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
      // prefer deviceId when available
      let constraintsVideo = {};
      if(deviceId){ constraintsVideo.deviceId = { exact: deviceId }; }
      else if(facingMode){ constraintsVideo.facingMode = { ideal: facingMode }; }
      else { constraintsVideo.facingMode = { ideal: 'environment' }; }
      constraintsVideo.width = { ideal: 1280 }; constraintsVideo.height = { ideal: 720 };
      const constraints = { video: constraintsVideo, audio: false };

      const s = await navigator.mediaDevices.getUserMedia(constraints);
      stream = s;
      preview.srcObject = s;
      await preview.play();
      // update devices (labels often appear after permission)
      await getDevices();
      // preselect the actual track deviceId if available
      try{
        const track = s.getVideoTracks()[0];
        const settings = track.getSettings();
        if(settings.deviceId){ deviceSelect.value = settings.deviceId; }
      }catch(e){/* ignore */}
      hiddenCanvas.width = preview.videoWidth || 640; hiddenCanvas.height = preview.videoHeight || 480;
      renderStage();
    }catch(err){
      console.error('startCamera error', err);
      alert('Camera access failed: '+ err.message + '
Make sure site is served over HTTPS and camera permission is allowed.');
    }
  }

  // device selection change
  deviceSelect.addEventListener('change', ()=> startCamera({deviceId: deviceSelect.value}));
  facingSelect.addEventListener('change', ()=> startCamera({facingMode: facingSelect.value}));

  // try auto-start but wrapped in try/catch. If blocked, user can click Start Camera.
  try{ await startCamera({facingMode: facingSelect.value}); }catch(e){ /* ignore */ }

  startCameraBtn.addEventListener('click', ()=> startCamera({deviceId: deviceSelect.value || null, facingMode: facingSelect.value}));

  // overlay and bg
  overlayFile.addEventListener('change', e=>{
    const f = e.target.files[0]; if(!f) return; const url = URL.createObjectURL(f); overlayPreview.src = url; overlayImg = new Image(); overlayImg.onload = ()=> renderStage(); overlayImg.src = url;
  });
  bgFile.addEventListener('change', e=>{ const f = e.target.files[0]; if(!f) return; const url = URL.createObjectURL(f); bgPreview.src = url; bgImg = new Image(); bgImg.onload = ()=> renderStage(); bgImg.src = url; });

  // capture with chroma support
  function captureFrameToCanvas(){
    if(!preview.videoWidth || !preview.videoHeight){ hiddenCanvas.width = 640; hiddenCanvas.height = 480; hiddenCtx.fillStyle='#444'; hiddenCtx.fillRect(0,0,hiddenCanvas.width,hiddenCanvas.height); return; }
    const w = hiddenCanvas.width = preview.videoWidth; const h = hiddenCanvas.height = preview.videoHeight;
    hiddenCtx.drawImage(preview,0,0,w,h);
    if(!chromaToggle.checked || !bgImg) return;
    // create temp bg sized to w,h
    const temp = document.createElement('canvas'); temp.width = w; temp.height = h; const tctx = temp.getContext('2d'); tctx.drawImage(bgImg,0,0,w,h);
    const fg = hiddenCtx.getImageData(0,0,w,h); const bg = tctx.getImageData(0,0,w,h);
    const key = hexToRgb(keyColorEl.value); const th = Number(thresholdEl.value);
    for(let i=0;i<fg.data.length;i+=4){ const r=fg.data[i], g=fg.data[i+1], b=fg.data[i+2]; const dist = Math.sqrt((r-key.r)**2+(g-key.g)**2+(b-key.b)**2); if(dist < th){ fg.data[i]=bg.data[i]; fg.data[i+1]=bg.data[i+1]; fg.data[i+2]=bg.data[i+2]; fg.data[i+3]=bg.data[i+3]; } }
    hiddenCtx.putImageData(fg,0,0);
  }

  function captureWithChroma(){ captureFrameToCanvas(); const dataUrl = hiddenCanvas.toDataURL('image/png'); const img = new Image(); img.src = dataUrl; captures.push(img); img.onload = ()=>{ renderThumbs(); renderStage(); }; }

  // countdown utility
  function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
  async function doCountdown(seconds){ if(!seconds || seconds<=0) return; countdownEl.style.display='flex'; for(let s=seconds;s>0;s--){ countdownEl.textContent = s; await sleep(1000); } countdownEl.style.display='none'; }

  // start capture sequence
  startBtn.addEventListener('click', async ()=>{
    captures = [];
    const count = Number(countEl.value);
    const delay = Number(delayEl.value);
    for(let i=0;i<count;i++){
      await doCountdown(delay);
      captureWithChroma();
      await sleep(300);
    }
  });
  snapBtn.addEventListener('click', ()=>{ captureWithChroma(); });

  // thumbs
  function renderThumbs(){ thumbs.innerHTML=''; captures.forEach((img,idx)=>{ const t=document.createElement('img'); t.src=img.src; t.className='thumb'; t.title = `Shot ${idx+1}`; t.addEventListener('click', ()=>{ /* focus or replace logic if needed */ }); thumbs.appendChild(t); }); }

  // compute layout slots (based on stage 360x540)
  function computeSlots(templateName, count){ const W=360,H=540, slots=[]; if(templateName==='grid2x2'){ const cols=2, rows=2; const w=W/cols, h=H/rows; for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){ slots.push({x:Math.round(c*w+6), y:Math.round(r*h+6), w:Math.round(w-12), h:Math.round(h-12)}); } }
    else if(templateName==='strip3'){ const hSlot = H/3; for(let i=0;i<3;i++) slots.push({x:12,y:Math.round(i*hSlot+8),w:W-24,h:Math.round(hSlot-16)}); }
    else { slots.push({x:8,y:8,w:W-16,h:H-16}); }
    return slots.slice(0, Math.max(1, Number(count)) ); }

  function drawImageCover(ctx,img,x,y,w,h){ const iw=img.width, ih=img.height; if(!iw||!ih) return; const r=Math.max(w/iw,h/ih); const nw=iw*r, nh=ih*r; const cx = x + (w-nw)/2, cy = y + (h-nh)/2; ctx.drawImage(img, cx, cy, nw, nh); }

  function previewToImageSync(){ const temp=document.createElement('canvas'); temp.width = preview.videoWidth || 640; temp.height = preview.videoHeight || 480; temp.getContext('2d').drawImage(preview,0,0,temp.width,temp.height); const img=new Image(); img.src = temp.toDataURL('image/png'); return img; }

  // rendering the stage and result preview
  function renderStage(){ const w=stageCanvas.width=360,h=stageCanvas.height=540; stageCtx.clearRect(0,0,w,h); stageCtx.fillStyle='#222'; stageCtx.fillRect(0,0,w,h);
    const slots = computeSlots(template, Number(countEl.value));
    slots.forEach((slot,i)=>{ stageCtx.save(); const img = captures[i] || previewToImageSync(); if(img){ drawImageCover(stageCtx,img,slot.x,slot.y,slot.w,slot.h); } else { stageCtx.fillStyle='#333'; stageCtx.fillRect(slot.x,slot.y,slot.w,slot.h); } stageCtx.restore(); });
    if(overlayImg) drawImageCover(stageCtx, overlayImg, 0, 0, w, h);
    // texts
    texts.forEach(t=>{ stageCtx.font = `${t.size||24}px ${t.font}`; stageCtx.fillStyle=t.color||'white'; stageCtx.strokeStyle='rgba(0,0,0,0.6)'; stageCtx.lineWidth=3; stageCtx.strokeText(t.text, t.x, t.y); stageCtx.fillText(t.text, t.x, t.y); });
    composeResultPreview(); }

  function composeResultPreview(){ const outW=1200,outH=1800; const tmp=document.createElement('canvas'); tmp.width=outW; tmp.height=outH; const tctx=tmp.getContext('2d'); tctx.fillStyle='white'; tctx.fillRect(0,0,outW,outH);
    const stageSlots = computeSlots(template, Number(countEl.value)); stageSlots.forEach((s,i)=>{ const sx = Math.round(s.x/360 * outW); const sy = Math.round(s.y/540 * outH); const sw = Math.round(s.w/360 * outW); const sh = Math.round(s.h/540 * outH); const img = captures[i] || previewToImageSync(); if(img) drawImageCover(tctx,img,sx,sy,sw,sh); });
    if(overlayImg) drawImageCover(tctx, overlayImg, 0, 0, outW, outH);
    texts.forEach(t=>{ const fontSize = Math.round((t.size||24) * (outW/360)); tctx.font = `${fontSize}px ${t.font}`; tctx.fillStyle=t.color||'white'; tctx.strokeStyle='rgba(0,0,0,0.6)'; tctx.lineWidth = Math.max(4, Math.round(6*(outW/360))); const x = Math.round(t.x/360 * outW); const y = Math.round(t.y/540 * outH); tctx.strokeText(t.text,x,y); tctx.fillText(t.text,x,y); });
    // draw scaled to preview
    resultCtx.clearRect(0,0,resultPreview.width,resultPreview.height); resultCtx.drawImage(tmp,0,0,resultPreview.width,resultPreview.height);
  }

  // export final
  exportBtn.addEventListener('click', ()=>{
    const outW=1200,outH=1800; const tmp=document.createElement('canvas'); tmp.width=outW; tmp.height=outH; const tctx=tmp.getContext('2d'); tctx.fillStyle='white'; tctx.fillRect(0,0,outW,outH);
    const stageSlots = computeSlots(template, Number(countEl.value)); stageSlots.forEach((s,i)=>{ const sx = Math.round(s.x/360 * outW); const sy = Math.round(s.y/540 * outH); const sw = Math.round(s.w/360 * outW); const sh = Math.round(s.h/540 * outH); const img = captures[i] || previewToImageSync(); if(img) drawImageCover(tctx,img,sx,sy,sw,sh); });
    if(overlayImg) drawImageCover(tctx, overlayImg, 0, 0, outW, outH);
    texts.forEach(t=>{ const fontSize = Math.round((t.size||24) * (outW/360)); tctx.font = `${fontSize}px ${t.font}`; tctx.fillStyle=t.color||'white'; tctx.strokeStyle='rgba(0,0,0,0.6)'; tctx.lineWidth = Math.max(4, Math.round(6*(outW/360))); const x=Math.round(t.x/360*outW); const y=Math.round(t.y/540*outH); tctx.strokeText(t.text,x,y); tctx.fillText(t.text,x,y); });
    const dataUrl = tmp.toDataURL('image/jpeg',0.95); const a=document.createElement('a'); a.href=dataUrl; a.download='mediabox_photobooth_4x6.jpg'; a.click();
  });

  // text overlays management
  addTextBtn.addEventListener('click', ()=>{ const txt = textInput.value.trim(); if(!txt) return; const obj = { text: txt, x: 40, y: 520, font: fontSelect.value, size: 24, color: 'white' }; texts.push(obj); textInput.value=''; renderStage(); enableTextDrag(); });
  clearTextsBtn.addEventListener('click', ()=>{ texts=[]; renderStage(); });

  // drag texts on stage
  function enableTextDrag(){ const holder = document.getElementById('stageHolder'); let dragging = null; let offset={x:0,y:0};
    holder.onpointerdown = (ev)=>{ const rect = holder.getBoundingClientRect(); const px = ev.clientX - rect.left; const py = ev.clientY - rect.top; for(let i=texts.length-1;i>=0;i--){ const t = texts[i]; stageCtx.font = `${t.size||24}px ${t.font}`; const w = stageCtx.measureText(t.text).width; const th = (t.size||24); if(px>=t.x && px<=t.x+w && py>=t.y-th && py<=t.y){ dragging={i}; offset.x = px - t.x; offset.y = py - t.y; holder.setPointerCapture(ev.pointerId); break; } } };
    holder.onpointermove = (ev)=>{ if(!dragging) return; const rect = holder.getBoundingClientRect(); const px = ev.clientX - rect.left; const py = ev.clientY - rect.top; const t = texts[dragging.i]; t.x = Math.max(0, Math.min(320, px - offset.x)); t.y = Math.max(24, Math.min(520, py - offset.y)); renderStage(); };
    holder.onpointerup = (ev)=>{ if(dragging){ try{ ev.target.releasePointerCapture(ev.pointerId); }catch(e){} dragging=null; } };
  }

  // template switching
  templates.addEventListener('click', e=>{ const t = e.target.closest('.template'); if(!t) return; document.querySelectorAll('.template').forEach(x=>x.classList.remove('active')); t.classList.add('active'); template = t.dataset.template; renderStage(); });

  // helper hex->rgb
  function hexToRgb(hex){ const m = hex.replace('#',''); return {r:parseInt(m.substring(0,2),16), g:parseInt(m.substring(2,4),16), b:parseInt(m.substring(4,6),16)} }

  // reset
  resetBtn.addEventListener('click', ()=>{ if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } captures=[]; overlayImg=null; overlayPreview.src=''; bgImg=null; bgPreview.src=''; texts=[]; thumbs.innerHTML=''; renderStage(); });

  // init
  renderStage(); enableTextDrag(); navigator.mediaDevices.addEventListener('devicechange', getDevices);

  // make sure UI updates when count or layout changed
  countEl.addEventListener('change', renderStage);
  delayEl.addEventListener('change', ()=>{});

})();
</script>
</body>
</html>
